(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{685:function(v,_,e){"use strict";e.r(_);var l=e(62),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"vue3-0优势"}},[v._v("Vue3.0优势")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Performance：性能更比Vue 2.0强。")]),v._v(" "),e("ul",[e("li",[v._v("重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。")]),v._v(" "),e("li",[v._v("编译模板的优化。")]),v._v(" "),e("li",[v._v("更高效的组件初始化。")]),v._v(" "),e("li",[v._v("update性能提高 1.3~2 倍。")]),v._v(" "),e("li",[v._v("SSR(服务端渲染)速度提高了 2~3 倍。")])])]),v._v(" "),e("li",[e("p",[v._v("Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。")]),v._v(" "),e("ul",[e("li",[v._v("可以将无用模块“剪辑”，仅打包需要的（比如v-model指令,transition组件，用不到就不会打包）。")]),v._v(" "),e("li",[v._v("一个简单“HelloWorld”大小仅为：13.5kb （11.75kb，仅Composition API。包含运行时完整功能：22.5kb）")]),v._v(" "),e("li",[v._v("拥有更多的功能，却比Vue 2更迷你。")]),v._v(" "),e("li",[v._v("很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入。")])])]),v._v(" "),e("li",[e("p",[v._v("Composition API：组合API")]),v._v(" "),e("ul",[e("li",[v._v("可与现有的 Options API一起使用")]),v._v(" "),e("li",[v._v("灵活的逻辑组合与复用")]),v._v(" "),e("li",[v._v("vue 3的响应式模块可以和其他框架搭配使用")]),v._v(" "),e("li",[v._v("混入(mixin) 将不再作为推荐使用， Composition API可以实现更灵活且无副作用的复用代码。")])])]),v._v(" "),e("li",[e("p",[v._v("Fragment, Teleport, Suspense")]),v._v(" "),e("ul",[e("li",[v._v("1.Fragment\n"),e("ul",[e("li",[v._v("不再限于模板中的单个根节点")]),v._v(" "),e("li",[v._v("render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。")]),v._v(" "),e("li",[v._v("‘Just works’")])])]),v._v(" "),e("li",[v._v("2.Teleport\n"),e("ul",[e("li",[v._v("以前称为Portal，译作传送门。")]),v._v(" "),e("li",[v._v("更多细节将由@Linusborg 分享")]),v._v(" "),e("li",[v._v("Teleport原先是对标 React Portal（增加多个新功能，更强）")])])]),v._v(" "),e("li",[v._v("3.Suspense\n"),e("ul",[e("li",[v._v("Suspense翻译为：“悬念”")]),v._v(" "),e("li",[v._v("可在嵌套层级中等待嵌套的异步依赖项")]),v._v(" "),e("li",[v._v("支持async setup()")]),v._v(" "),e("li",[v._v("支持异步组件")]),v._v(" "),e("li",[v._v("虽然React 16引入了Suspense，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。")]),v._v(" "),e("li",[v._v("Vue 3 的Suspense更加轻量：")]),v._v(" "),e("li",[v._v("仅 5%应用能感知运行时的调度差异，综合考虑下，Vue3 的Suspense 没和 React 一样做运行调度处理")])])])])]),v._v(" "),e("li",[e("p",[v._v("Better TypeScript support：更好的TypeScript支持")]),v._v(" "),e("ul",[e("li",[v._v("Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示")]),v._v(" "),e("li",[v._v("JavaScript和TypeScript中的 API 是相同的。事实上，代码也基本相同")]),v._v(" "),e("li",[v._v("支持TSX")]),v._v(" "),e("li",[v._v("class组件还会继续支持，但是需要引入vue-class-component@next，该模块目前还处在 alpha 阶段。")])])]),v._v(" "),e("li",[e("p",[v._v("Custom Renderer API：暴露了自定义渲染API")]),v._v(" "),e("ul",[e("li",[v._v("正在进行NativeScript Vue集成")]),v._v(" "),e("li",[v._v("用户可以尝试WebGL自定义渲染器，与普通 Vue 应用程序一起使用（Vugel）。")])])])]),v._v(" "),e("h2",{attrs:{id:"总结："}},[v._v("总结：")]),v._v(" "),e("ul",[e("li",[v._v("从学习成本和稳定性上考虑，选vue2")]),v._v(" "),e("li",[v._v("除此之外选vue3")])])])}),[],!1,null,null,null);_.default=i.exports}}]);